Hi Paul, here is a sample file in the ARIES language that models a Bookshop application which has buyer, seller, and supplier components.  Not included here are the associated BPEL, WSDL, and XSD files that provide the standard plumbing normally provided by those types of files.

The Java-based generation system we have built called NAM (Network Application Modeler) which reads/parses this ARIES file, will autogeneric *all* projects, source codes, schema files, config files, build scripts, deployment descriptors etc... required to build, deploy, execute, manage and maintain the application. Also auto-generated is a simple web-based UI.  Also autogenerated are tests which test the application at different levels (unit-level, thread-level, process-level, and application-level).

The system enables specification and generation of business logic as both short-running and long-running multiparty business processes.

It is considered a single transactional workflow with several stages and several entry-points.  In order to support the workflow transactionality, there is a mixture of Atomic (short-term) transactions together with Business Activity (long-term) transactions.  Cancellation and rollback may occur at numerous different points in the workflow.  Depending upon where in the workflow cancellation or rollback is triggered, different things may happen.  Any Business Activity transaction will have its corresponding compensating transaction executed.  Also, any intermediate commits of Atomic Transactions will also be compensated for as well.

The resulting application that is generated is a fully functioning, Java-based, multi-module, enterprise application system that integrates several key technologies including distributed shared memory caching, fully distributed two-phase commit transactions, asynchronous messaging, as well as service and process replication with associated load-balancing, failover handling.  Transactional behaviour and data integrity are matained regardless of communication transport/protocol (either HTTP, JMS, EJB, RMI, or CORBA) that is used (i.e. that is configured specific for each communication link).

Implementation support of the backend portion of generated app may include: 
EMF, EJB, JBoss Seam, EhCache, JGroups, JMX

Implementation support of the frontend portion of generated app may include: 
JSF, Richfaces, Ajax4Jsf, JBoss Seam (and no Javascript required!)

Implementation support of the Communications Layer (the specifications of which are completely decoupled from the business portion of the app) may include: 
JAXWS, JMS, RMI, EJB, CORBA, FTP, SMTP

Implementation support of the Persistence Layer may include:
EMF, JPA (implemented using Hibernate)


Also of Interest:
-EIP Patterns implemented using BPEL
 (Splitter)

The way we both model and generate module depenencies and dependency management is simple and essential. When using 3rd party modules (which most all projects are doing at this time) it is a challenge to ensure that versions and version dependncies are all "clean".  What we mean by "clean" is described here.  This is an area of extreme high risk.  Needs to be squarely addressed.  Typically nowadays most efforts fall short of achieving "clean" dependencies.


